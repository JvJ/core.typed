<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>clojure.core.typed - Gradual Typing 0.1.25 API documentation</title>
    <link href="static/favicon.png" rel="icon" />
    <link href="static/favicon.png" rel="shortcut icon" />
    <link media="all" type="text/css" href="static/clojure.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/wiki.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/internal.css" rel="stylesheet" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a id="Logo" href="index.html"><img alt="Clojure" height="100" width="100" src="static/clojure-icon.gif" /></a>
	<h1><a title="page header title" id="page-header" href="index.html">core.typed API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">Gradual Typing</span> <span id="version">0.1.25</span> API</span><br />
    <ul>
      <li><a class="wiki_link" href="index.html">Overview</a></li>
      <li><a class="wiki_link" href="api-index.html">API Index</a></li>
    </ul>
    
    
    <a href="http://clojure.org" class="wiki_link">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div id="content_view" class="wiki wikiPage">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div style="margin-left: 1em;" class="toc-section">
    <a href="#toc0" style="margin-top: 3px;">Overview</a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#" style="margin-top: 3px;"></a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#" style="margin-top: 3px;"></a>
    
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#var-section" style="margin-top: 3px;">Vars and Functions</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/*verbose-forms*">*verbose-forms*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/*verbose-types*">*verbose-types*</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann">ann</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-datatype">ann-datatype</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-form">ann-form</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-many">ann-many</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-precord">ann-precord</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-protocol">ann-protocol</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/ann-record">ann-record</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/cf">cf</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/check-ns">check-ns</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-alias-kind">declare-alias-kind</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-datatypes">declare-datatypes</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-names">declare-names</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/declare-protocols">declare-protocols</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/def-alias">def-alias</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/doseq&gt;">doseq&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/dotimes&gt;">dotimes&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/fn&gt;">fn&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/for&gt;">for&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/inst">inst</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/inst-ctor">inst-ctor</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/into-array&gt;">into-array&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/letfn&gt;">letfn&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/load-if-needed">load-if-needed</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/loop&gt;">loop&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/method-type">method-type</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/nilable-param">nilable-param</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/non-nil-return">non-nil-return</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/override-constructor">override-constructor</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/override-method">override-method</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/pfn&gt;">pfn&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/print-env">print-env</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/print-filterset">print-filterset</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/reset-caches">reset-caches</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/tc-ignore">tc-ignore</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/typed-deps">typed-deps</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/warn-on-unannotated-vars">warn-on-unannotated-vars</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed/when-let-fail">when-let-fail</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.async" style="margin-top: 3px;">clojure.core.typed.async</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/Buffer">Buffer</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/Chan">Chan</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/Port">Port</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/ReadOnlyChan">ReadOnlyChan</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/ReadOnlyPort">ReadOnlyPort</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/TimeoutChan">TimeoutChan</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/WriteOnlyPort">WriteOnlyPort</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/buffer&gt;">buffer&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/chan&gt;">chan&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/dropping-buffer&gt;">dropping-buffer&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/go&gt;">go&gt;</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.async/sliding-buffer&gt;">sliding-buffer&gt;</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.collect-phase" style="margin-top: 3px;">clojure.core.typed.collect-phase</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.collect-phase/collect-ns">collect-ns</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.collect-phase/infer-typed-ns-deps!">infer-typed-ns-deps!</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.datatype-env" style="margin-top: 3px;">clojure.core.typed.datatype-env</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.datatype-env/DataTypeEnv">DataTypeEnv</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.datatype-env/get-datatype">get-datatype</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.datatype-env/resolve-datatype">resolve-datatype</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.filter-rep" style="margin-top: 3px;">clojure.core.typed.filter-rep</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/AndFilter">AndFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/BotFilter">BotFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/FilterSet">FilterSet</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/ImpFilter">ImpFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/NoFilter">NoFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/NotTypeFilter">NotTypeFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/OrFilter">OrFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/TopFilter">TopFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/TypeFilter">TypeFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/-&gt;AndFilter">-&gt;AndFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/-&gt;BotFilter">-&gt;BotFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/-&gt;FilterSet">-&gt;FilterSet</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/-&gt;ImpFilter">-&gt;ImpFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/-&gt;NoFilter">-&gt;NoFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/-&gt;NotTypeFilter">-&gt;NotTypeFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/-&gt;OrFilter">-&gt;OrFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/-&gt;TopFilter">-&gt;TopFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/-&gt;TypeFilter">-&gt;TypeFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/NameRef">NameRef</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/map-&gt;AndFilter">map-&gt;AndFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/map-&gt;BotFilter">map-&gt;BotFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/map-&gt;FilterSet">map-&gt;FilterSet</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/map-&gt;ImpFilter">map-&gt;ImpFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/map-&gt;NoFilter">map-&gt;NoFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/map-&gt;NotTypeFilter">map-&gt;NotTypeFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/map-&gt;OrFilter">map-&gt;OrFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/map-&gt;TopFilter">map-&gt;TopFilter</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.filter-rep/map-&gt;TypeFilter">map-&gt;TypeFilter</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.hole" style="margin-top: 3px;">clojure.core.typed.hole</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/NoisyHole">NoisyHole</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/-&gt;NoisyHole">-&gt;NoisyHole</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/noisy-hole">noisy-hole</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.hole/silent-hole">silent-hole</a>
      
    </div>
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#clojure.core.typed.object-rep" style="margin-top: 3px;">clojure.core.typed.object-rep</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.object-rep/EmptyObject">EmptyObject</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.object-rep/NoObject">NoObject</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.object-rep/Path">Path</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.object-rep/-&gt;EmptyObject">-&gt;EmptyObject</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.object-rep/-&gt;NoObject">-&gt;NoObject</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.object-rep/-&gt;Path">-&gt;Path</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.object-rep/map-&gt;EmptyObject">map-&gt;EmptyObject</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.object-rep/map-&gt;NoObject">map-&gt;NoObject</a>
      
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a class="toc-entry-anchor" href="#clojure.core.typed.object-rep/map-&gt;Path">map-&gt;Path</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.core.typed">clojure.core.typed</span>
  - <span id="header-project">Gradual Typing</span> <span id="header-version">0.1.25</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>

<br />Full namespace name: <span id="long-name">clojure.core.typed</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="http://github.com/clojure/core.typed/">http://github.com/clojure/core.typed/</a></div>
<pre id="namespace-docstr"></pre>


<br />



<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/*verbose-forms*">*verbose-forms*</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">If true, print complete forms in error messages.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L1155" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/*verbose-types*">*verbose-types*</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">If true, print fully qualified types in error messages
and return values.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L1151" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann">ann</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann varsym typesyn)
</pre>
    <pre id="var-docstr">Annotate varsym with type. If unqualified, qualify in the current namespace.
If varsym has metadata {:no-check true}, ignore definitions of varsym 
while type checking.

eg. ; annotate the var foo in this namespace
    (ann foo [Number -&gt; Number])

    ; annotate a var in another namespace
    (ann another.ns/bar [-&gt; nil])
 
    ; don't check this var
    (ann ^:no-check foobar [Integer -&gt; String])</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L812" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-datatype">ann-datatype</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-datatype &amp; args)
</pre>
    <pre id="var-docstr">Annotate datatype Class name dname with expected fields.
If unqualified, qualify in the current namespace.

eg. (ann-datatype MyDatatype [a :- Number,
                              b :- Long])
    
    (ann-datatype another.ns.TheirDatatype
                  [str :- String,
                   vec :- (IPersistentVector Number)])</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L854" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-form">ann-form</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-form form ty)
</pre>
    <pre id="var-docstr">Annotate a form with an expected type.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L739" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-many">ann-many</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-many t &amp; vs)
</pre>
    <pre id="var-docstr">Annotate several vars with type t.

eg. (ann-many FakeSearch
              web1 web2 image1 image2 video1 video2)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L840" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-precord">ann-precord</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-precord dname vbnd fields &amp; {ancests :unchecked-ancestors, rplc :replace, :as opt})
</pre>
    <pre id="var-docstr">Annotate record Class name dname with a polymorphic binder and expected fields.
If unqualified, qualify in the current namespace.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L914" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-protocol">ann-protocol</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-protocol &amp; args)
</pre>
    <pre id="var-docstr">Annotate a possibly polymorphic protocol var with method types.

eg. (ann-protocol IFoo
      bar
      [IFoo -&gt; Any]
      baz
      [IFoo -&gt; Number])

    ; polymorphic
    (ann-protocol [[x :variance :covariant]]
      IFoo
      bar
      [IFoo -&gt; Any]
      baz
      [IFoo -&gt; Number])</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L926" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/ann-record">ann-record</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (ann-record dname fields &amp; {ancests :unchecked-ancestors, rplc :replace, :as opt})
</pre>
    <pre id="var-docstr">Annotate record Class name dname with expected fields.
If unqualified, qualify in the current namespace.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L902" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/cf">cf</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (cf form)
       (cf form expected)
</pre>
    <pre id="var-docstr">Takes a form and an optional expected type and
returns a human-readable inferred type for that form.

eg. (cf 1) 
    ;=&gt; "Long"

    (cf #(inc %) [Number -&gt; Number)
    ;=&gt; "[Number -&gt; Number]</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L1039" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/check-ns">check-ns</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (check-ns)
       (check-ns ns-or-sym)
</pre>
    <pre id="var-docstr">Type check a namespace. If not provided default to current namespace.
Returns a true value if type checking is successful, otherwise
throws an Exception.

Bind *verbose-types* to true to print fully qualified types.
Bind *verbose-forms* to print full forms in error messages.

eg. (check-ns 'myns.typed)
    ;=&gt; :ok
   
    ;implicitly check current namespace
    (binding [*ns* (find-ns 'myns.typed)]
      (check-ns))
    ;=&gt; :ok</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L1177" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-alias-kind">declare-alias-kind</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-alias-kind sym ty)
</pre>
    <pre id="var-docstr">Declare a kind for an alias, similar to declare but on the kind level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L645" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-datatypes">declare-datatypes</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-datatypes &amp; syms)
</pre>
    <pre id="var-docstr">Declare datatypes, similar to declare but on the type level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L623" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-names">declare-names</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-names &amp; syms)
</pre>
    <pre id="var-docstr">Declare names, similar to declare but on the type level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L658" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/declare-protocols">declare-protocols</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (declare-protocols &amp; syms)
</pre>
    <pre id="var-docstr">Declare protocols, similar to declare but on the type level.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L634" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/def-alias">def-alias</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (def-alias sym doc-str t)
       (def-alias sym t)
</pre>
    <pre id="var-docstr">Define a type alias. Takes an optional doc-string as a second
argument.

Updates the corresponding var with documentation.

eg. (def-alias MyAlias
      "Here is my alias"
      (U nil String))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L669" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/doseq&gt;">doseq&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (doseq&gt; seq-exprs &amp; body)
</pre>
    <pre id="var-docstr">Like doseq but requires annotation for each loop variable: 
[a [1 2]] becomes [a :- Long [1 2]]

eg.
(doseq&gt; [a :- (U nil AnyInteger) [1 nil 2 3]
         :when a]
   (inc a))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L296" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/dotimes&gt;">dotimes&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (dotimes&gt; bindings &amp; body)
</pre>
    <pre id="var-docstr">Like dotimes.

eg. (dotimes&gt; [_ 100]
      (println "like normal"))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L154" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/fn&gt;">fn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (fn&gt; &amp; forms)
</pre>
    <pre id="var-docstr">Like fn, but with annotations. Annotations are mandatory
for parameters, with optional annotations for return type.
If fn is named, return type annotation is mandatory.

Suggested idiom: use commas between parameter annotation triples.

eg. (fn&gt; [a :- Number, b :- (U Symbol nil)] ...)

    ;annotate return
    (fn&gt; :- String [a :- String] ...)

    ;named fn
    (fn&gt; fname :- String [a :- String] ...)

    ;multi-arity
    (fn&gt; fname 
      (:- String [a :- String] ...)
      (:- Long   [a :- String, b :- Number] ...))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L498" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/for&gt;">for&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (for&gt; tk ret-ann seq-exprs body-expr)
</pre>
    <pre id="var-docstr">Like for but requires annotation for each loop variable: [a [1 2]] becomes [a :- Long [1 2]]
Also requires annotation for return type.

eg. (for&gt; :- Number
      [a :- (U nil AnyInteger) [1 nil 2 3]
       :when a]
      (inc a))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L171" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/inst">inst</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (inst inst-of &amp; types)
</pre>
    <pre id="var-docstr">Instantiate a polymorphic type with a number of types</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L124" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/inst-ctor">inst-ctor</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (inst-ctor inst-of &amp; types)
</pre>
    <pre id="var-docstr">Instantiate a call to a constructor with a number of types.
First argument must be an immediate call to a constructor.
Returns exactly the instantiatee (the first argument).</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L129" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/into-array&gt;">into-array&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (into-array&gt; cljt coll)
       (into-array&gt; javat cljt coll)
       (into-array&gt; into-array-syn javat cljt coll)
</pre>
    <pre id="var-docstr">Make a Java array with Java class javat and Typed Clojure type
cljt. Resulting array will be of type javat, but elements of coll must be under
cljt. cljt should be a subtype of javat (the same or more specific).

*Temporary hack*
into-array-syn is exactly the syntax to put as the first argument to into-array.
Calling resolve on this syntax should give the correct class.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L718" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/letfn&gt;">letfn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (letfn&gt; fn-specs-and-annotations &amp; body)
</pre>
    <pre id="var-docstr">Like letfn, but each function spec must be annotated.

eg. (letfn&gt; [a :- [Number -&gt; Number]
             (a [b] 2)

             c :- [Symbol -&gt; nil]
             (c [s] nil)]
      ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L524" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/load-if-needed">load-if-needed</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (load-if-needed)
</pre>
    <pre id="var-docstr">Load and initialize all of core.typed if not already</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L28" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/loop&gt;">loop&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (loop&gt; bndings* &amp; forms)
</pre>
    <pre id="var-docstr">Like loop, except loop variables require annotation.

Suggested idiom: use a comma between the type and the initial
expression.

eg. (loop&gt; [a :- Number, 1
            b :- (U nil Number), nil]
      ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L577" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/method-type">method-type</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (method-type mname)
</pre>
    <pre id="var-docstr">Given a method symbol, print the core.typed types assigned to it.
Intended for use at the REPL.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L77" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/nilable-param">nilable-param</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (nilable-param msym mmap)
</pre>
    <pre id="var-docstr">Override which parameters in qualified method msym may accept
nilable values. If the parameter is a parameterised type or
an Array, this also declares the parameterised types and the Array type as nilable.

mmap is a map mapping arity parameter number to a set of parameter
positions (integers). If the map contains the key :all then this overrides
other entries. The key can also be :all, which declares all parameters nilable.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L786" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/non-nil-return">non-nil-return</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (non-nil-return msym arities)
</pre>
    <pre id="var-docstr">Override the return type of qualified method msym to be non-nil.
Takes a set of relevant arities,
represented by the number of parameters it takes (rest parameter counts as one),
or :all which overrides all arities.

eg.  (non-nil-return java.lang.Class/getDeclaredMethod :all)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L770" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/override-constructor">override-constructor</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (override-constructor ctorsym typesyn)
</pre>
    <pre id="var-docstr">Override all constructors for Class ctorsym with type.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L973" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/override-method">override-method</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (override-method methodsym typesyn)
</pre>
    <pre id="var-docstr">Override type for qualified method methodsym.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L984" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/pfn&gt;">pfn&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (pfn&gt; &amp; forms)
</pre>
    <pre id="var-docstr">Define a polymorphic typed anonymous function.
(pfn&gt; name? [binder+] :- type? [[param :- type]* &amp; [param :- type *]?] exprs*)
(pfn&gt; name? [binder+] (:- type? [[param :- type]* &amp; [param :- type *]?] exprs*)+)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L482" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/print-env">print-env</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-env debug-str)
</pre>
    <pre id="var-docstr">During type checking, print the type environment to *out*,
preceeded by literal string debug-str.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L800" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/print-filterset">print-filterset</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-filterset debug-string frm)
</pre>
    <pre id="var-docstr">During type checking, print the filter set attached to form, 
preceeded by literal string debug-string.
Returns nil.

eg. (let [s (seq (get-a-seqable))]
      (print-filterset "Here now" s))</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L102" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/reset-caches">reset-caches</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (reset-caches)
</pre>
    <pre id="var-docstr">Reset internal type caches.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L1168" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/tc-ignore">tc-ignore</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (tc-ignore &amp; body)
</pre>
    <pre id="var-docstr">Ignore forms in body during type checking</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L759" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/typed-deps">typed-deps</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (typed-deps &amp; args)
</pre>
    <pre id="var-docstr">Declare namespaces which should be checked before the current namespace.
Accepts any number of symbols.

eg. (typed-deps clojure.core.typed.holes
                myns.types)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L995" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/warn-on-unannotated-vars">warn-on-unannotated-vars</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (warn-on-unannotated-vars)
</pre>
    <pre id="var-docstr">Allow unannotated vars in the current namespace. 

Emits a warning instead of a type error when checking
a def without a corresponding expected type.

eg. (warn-on-unannotated-vars)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L1026" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed/when-let-fail">when-let-fail</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (when-let-fail b &amp; body)
</pre>
    <pre id="var-docstr">Like when-let, but fails if the binding yields a false value.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed.clj#L491" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.async">clojure.core.typed.async</h2>
<pre id="namespace-docstr">This namespace contains annotations and helper macros for type
checking core.async code. Ensure clojure.core.async is require'd
before performing type checking.

go
  use go&gt;

chan
  use chan&gt;

buffer
  use buffer&gt; (similar for other buffer constructors)
</pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/Buffer">Buffer</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A buffer of type x.

(TFn
 [[x :variance :invariant]]
 (clojure.core.async.impl.protocols/Buffer x))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/Chan">Chan</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A core.async channel

(TFn
 [[x :variance :invariant]]
 (Extends
  [(clojure.core.async.impl.protocols/WritePort x)
   (clojure.core.async.impl.protocols/ReadPort x)
   (clojure.core.async.impl.protocols/Channel x x)]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/Port">Port</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A port that can read and write type x

(TFn
 [[x :variance :invariant]]
 (Extends
  [(clojure.core.async.impl.protocols/ReadPort x)
   (clojure.core.async.impl.protocols/WritePort x)]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/ReadOnlyChan">ReadOnlyChan</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A core.async channel that statically disallows writes.

(TFn
 [[r :variance :covariant]]
 (Extends
  [(clojure.core.async.impl.protocols/WritePort Nothing)
   (clojure.core.async.impl.protocols/ReadPort r)
   (clojure.core.async.impl.protocols/Channel Nothing r)]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/ReadOnlyPort">ReadOnlyPort</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A read-only port that can read type x

(TFn
 [[r :variance :covariant]]
 (Extends
  [(clojure.core.async.impl.protocols/ReadPort r)
   (clojure.core.async.impl.protocols/WritePort Nothing)]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/TimeoutChan">TimeoutChan</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A timeout channel

(Chan Any)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/WriteOnlyPort">WriteOnlyPort</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A write-only port that can write type x

(TFn
 [[x :variance :invariant]]
 (Extends
  [(clojure.core.async.impl.protocols/ReadPort x)
   (clojure.core.async.impl.protocols/WritePort x)]))</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/buffer&gt;">buffer&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (buffer&gt; t &amp; args)
</pre>
    <pre id="var-docstr">A statically typed core.async buffer. 

(buffer&gt; t ...) creates a buffer that can read and write type t.
Subsequent arguments are passed directly to clojure.core.async/buffer.

Note: (buffer&gt; t ...) is the same as ((inst buffer t) ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/75da3a91f5a78b759d020961e5e8a1c4772e8475/src/main/clojure/clojure/core/typed/async.clj#L184" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/chan&gt;">chan&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (chan&gt; t &amp; args)
</pre>
    <pre id="var-docstr">A statically typed core.async channel. 

(chan&gt; t ...) creates a buffer that can read and write type t.
Subsequent arguments are passed directly to clojure.core.async/chan.

Note: 
(chan&gt; t ...) is the same as ((inst chan t) ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/75da3a91f5a78b759d020961e5e8a1c4772e8475/src/main/clojure/clojure/core/typed/async.clj#L173" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/dropping-buffer&gt;">dropping-buffer&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (dropping-buffer&gt; t &amp; args)
</pre>
    <pre id="var-docstr">A statically typed core.async dropping buffer. 

(dropping-buffer&gt; t ...) creates a dropping buffer that can read and write type t.
Subsequent arguments are passed directly to clojure.core.async/dropping-buffer.

Note: (dropping-buffer&gt; t ...) is the same as ((inst dropping-buffer t) ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/75da3a91f5a78b759d020961e5e8a1c4772e8475/src/main/clojure/clojure/core/typed/async.clj#L204" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/go&gt;">go&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (go&gt; &amp; body)
</pre>
    <pre id="var-docstr">Asynchronously executes the body, returning immediately to the
calling thread. Additionally, any visible calls to &lt;!, &gt;! and alt!/alts!
channel operations within the body will block (if necessary) by
'parking' the calling thread rather than tying up an OS thread (or
the only JS thread when in ClojureScript). Upon completion of the
operation, the body will be resumed.

Returns a channel which will receive the result of the body when
completed</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/75da3a91f5a78b759d020961e5e8a1c4772e8475/src/main/clojure/clojure/core/typed/async.clj#L147" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.async/sliding-buffer&gt;">sliding-buffer&gt;</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (sliding-buffer&gt; t &amp; args)
</pre>
    <pre id="var-docstr">A statically typed core.async sliding buffer. 

(sliding-buffer&gt; t ...) creates a sliding buffer that can read and write type t.
Subsequent arguments are passed directly to clojure.core.async/sliding-buffer.

Note: (sliding-buffer&gt; t ...) is the same as ((inst sliding-buffer t) ...)</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/75da3a91f5a78b759d020961e5e8a1c4772e8475/src/main/clojure/clojure/core/typed/async.clj#L194" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.collect-phase">clojure.core.typed.collect-phase</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.collect-phase/collect-ns">collect-ns</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (collect-ns nsym)
</pre>
    <pre id="var-docstr">Collect type annotations and dependency information
for namespace symbol nsym, and recursively check 
declared typed namespace dependencies.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/collect_phase.clj#L71" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.collect-phase/infer-typed-ns-deps!">infer-typed-ns-deps!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (infer-typed-ns-deps! nsym)
</pre>
    <pre id="var-docstr">Automatically find other namespaces that are likely to
be typed dependencies to the current ns.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/collect_phase.clj#L62" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.datatype-env">clojure.core.typed.datatype-env</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.datatype-env/DataTypeEnv">DataTypeEnv</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">An Environment mapping datatype symbols to types.

(IPersistentMap Symbol r/TCType)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.datatype-env/get-datatype">get-datatype</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (get-datatype sym)
</pre>
    <pre id="var-docstr">Get the datatype with class symbol sym.
Returns nil if not found.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed/datatype_env.clj#L42" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.datatype-env/resolve-datatype">resolve-datatype</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (resolve-datatype sym)
</pre>
    <pre id="var-docstr">Same as get-datatype, but fails if datatype is not found.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/e4acf081a6abc0cbbe0e2b71892bc2a1f89fd75b/src/main/clojure/clojure/core/typed/datatype_env.clj#L51" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.filter-rep">clojure.core.typed.filter-rep</h2>
<pre id="namespace-docstr"></pre>


<br />

<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/AndFilter">AndFilter</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[fs]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/BotFilter">BotFilter</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/FilterSet">FilterSet</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[then else]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/ImpFilter">ImpFilter</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[a c]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/NoFilter">NoFilter</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/NotTypeFilter">NotTypeFilter</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[type path id]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/OrFilter">OrFilter</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[fs]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/TopFilter">TopFilter</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/TypeFilter">TypeFilter</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[type path id]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/-&gt;AndFilter">-&gt;AndFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;AndFilter fs)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L73" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/-&gt;BotFilter">-&gt;BotFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;BotFilter)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L33" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/-&gt;FilterSet">-&gt;FilterSet</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;FilterSet then else)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L95" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/-&gt;ImpFilter">-&gt;ImpFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;ImpFilter a c)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L88" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/-&gt;NoFilter">-&gt;NoFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;NoFilter)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L48" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/-&gt;NotTypeFilter">-&gt;NotTypeFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;NotTypeFilter type path id)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L65" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/-&gt;OrFilter">-&gt;OrFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;OrFilter fs)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L80" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/-&gt;TopFilter">-&gt;TopFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;TopFilter)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L38" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/-&gt;TypeFilter">-&gt;TypeFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;TypeFilter type path id)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L55" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/NameRef">NameRef</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">A name for a type variable, either a symbol or a number.

(U Symbol Number)</pre>
    
    
    
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/map-&gt;AndFilter">map-&gt;AndFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;AndFilter {:as m#, :keys [fs]})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L73" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/map-&gt;BotFilter">map-&gt;BotFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;BotFilter {:as m#, :keys []})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L33" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/map-&gt;FilterSet">map-&gt;FilterSet</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;FilterSet {:as m#, :keys [then else]})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L95" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/map-&gt;ImpFilter">map-&gt;ImpFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;ImpFilter {:as m#, :keys [a c]})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L88" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/map-&gt;NoFilter">map-&gt;NoFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;NoFilter {:as m#, :keys []})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L48" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/map-&gt;NotTypeFilter">map-&gt;NotTypeFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;NotTypeFilter {:as m#, :keys [type path id]})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L65" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/map-&gt;OrFilter">map-&gt;OrFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;OrFilter {:as m#, :keys [fs]})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L80" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/map-&gt;TopFilter">map-&gt;TopFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;TopFilter {:as m#, :keys []})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L38" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.filter-rep/map-&gt;TypeFilter">map-&gt;TypeFilter</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;TypeFilter {:as m#, :keys [type path id]})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/filter_rep.clj#L55" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.hole">clojure.core.typed.hole</h2>
<pre id="namespace-docstr"></pre>


<br />

<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/NoisyHole">NoisyHole</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces"></span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/-&gt;NoisyHole">-&gt;NoisyHole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;NoisyHole)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.typed.hole.NoisyHole.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/5769b2da06f0cd7f21d115e789413191f4cb6ec2/src/main/clojure/clojure/core/typed/hole.clj#L14" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/noisy-hole">noisy-hole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (noisy-hole)
</pre>
    <pre id="var-docstr">A noisy hole. The type system will complain when
(noisy-hole) is used in positions that expect a type
more specific than Object or Any.
Use (noisy-hole) as a placeholder for code.
Throws an exception when evaluted.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/5769b2da06f0cd7f21d115e789413191f4cb6ec2/src/main/clojure/clojure/core/typed/hole.clj#L17" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.hole/silent-hole">silent-hole</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (silent-hole)
</pre>
    <pre id="var-docstr">A silent hole. (silent-hole) passes for any other type
when type checking.
Use (silent-hole) as a placeholder for code.
Throws an exception when evaluted.</pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/5769b2da06f0cd7f21d115e789413191f4cb6ec2/src/main/clojure/clojure/core/typed/hole.clj#L5" id="var-source">Source</a>
  </div>
</div>
<br />
<h2 id="clojure.core.typed.object-rep">clojure.core.typed.object-rep</h2>
<pre id="namespace-docstr"></pre>


<br />

<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.object-rep/EmptyObject">EmptyObject</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.object-rep/NoObject">NoObject</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.object-rep/Path">Path</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[path id]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.object-rep/-&gt;EmptyObject">-&gt;EmptyObject</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;EmptyObject)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/object_rep.clj#L25" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.object-rep/-&gt;NoObject">-&gt;NoObject</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;NoObject)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/object_rep.clj#L44" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.object-rep/-&gt;Path">-&gt;Path</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;Path path id)
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/object_rep.clj#L34" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.object-rep/map-&gt;EmptyObject">map-&gt;EmptyObject</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;EmptyObject {:as m#, :keys []})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/object_rep.clj#L25" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.object-rep/map-&gt;NoObject">map-&gt;NoObject</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;NoObject {:as m#, :keys []})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/object_rep.clj#L44" id="var-source">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.typed.object-rep/map-&gt;Path">map-&gt;Path</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;Path {:as m#, :keys [path id]})
</pre>
    <pre id="var-docstr"></pre>
    
    
    <a href="https://github.com/clojure/core.typed/blob/01f5802054988df89c51e2eb7b133d8dc5f634ca/src/main/clojure/clojure/core/typed/object_rep.clj#L34" id="var-source">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div style="text-align: center;" id="copyright">Copyright 2007-2013 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a title="Visit Tom Hickey's website." href="http://www.tomhickey.com">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>